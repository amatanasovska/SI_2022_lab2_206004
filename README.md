# Ана Марија Атанасовска 206004

2. Control Flow Graph

![graph](https://user-images.githubusercontent.com/86167204/170261819-07d28299-9fb9-497c-8207-fa49c76ba3f5.png)

3. 
Цикломатската комплексност можеме да ја пресметаме со форлмулата (бројот на ребра во графот) – (бројот на темиња во графот) + 2, а поради тоа што има 29 ребра и 22 темиња во графот добиваме 29-22+2 = 9) 

4. 
![image](https://user-images.githubusercontent.com/86167204/170672551-5f3e5359-18b5-4c67-abe5-559e77e62932.png)

Во првиот тест случај низата е празна и со него би ги изминале јазлите A и B и програмата ќе заврши по фрлањето на исклучок. Во вториот тест случај имаме несоодветна големина на листа, која е неполн квадрат и соодветно програмата ќе го измине јазолот А и од како нема да биде исполнет условот(наредба A), нема да навлезе во телото на if-структурата(наредба В), па ќе влезе во јазолот С, па во јазолот D каде програмата ќе заврши со фрлен исклучок. Последниот тест случај ги опфаќа сите јазли освен јазлите В и D.  Ќе се измине јазолот А, нема да биде исполнет условот(наредба A), нема да навлезе во телото на if-структурата(наредба В) и ќе продолжи кон јазолот С каде што повторно нема да биде исполнет условот(наредба С), нема да навлезе во телото на if-структурата(наредба D), ќе се декларира листа со навлегувањето во јазолот Е. Сега се навлегува во for-структурата, па така ќе се извршат јазлите F1, F2 и сега кога i ќе ја земе вредноста на индексите во листата каде што се наоѓа # знакот, а тоа се индексите 0,1,2,3,5,6,7 ќе се влезе во јазокот Q, потоа кога i ќе ја земе вредноста 4 ќе се навлезе во јазлите G,H, I, J, L,M,N,O,P, а соодветно кога i ќе ја завземе вредноста 8 се влегува во јазлите G,H,I,K,L,M,N,P. Јазолот F3 се изминува при крајот на секоја итерација. Дадената дискусија може да ја сумираме на следниот начин - кога се навлегува во for-циклусот i има вредност 0 и за конкретната низа на индексот 0 има знак # па како што дискутиравме прво ќе се измине јазелот G, па ќе се измине јазелот Q, па после тој јазол се навлегува во јазолот F3, се зголемува i, па во јазолот F2 каде се врши проверка, па понатака се извршуваат G Q F3 F2 G Q F3 F2 G Q F3 F2 G H  I  J  L M N O P F3 F2 G Q F3 F2 G Q F3 F2 G Q F3 F2 G H I K L M N P F3 F2 и од тука се навлегува во јазолот R и завршува програмата. 

5. 
![image](https://user-images.githubusercontent.com/86167204/170673041-785689cd-9c55-4f30-9884-042725b40477.png)

Преминот од јазол А кон јазол B ќе се случи само доколку имаме празна листа, па тоа ни е опфатено со првиот тест случај. Кога имаме листа со број на елементи кој не е полн квадрат ќе се случат премините од јазол А кон јазол С и од С кон јазол D. За последниот тест случај, листата треба да не е празна и да има број на елементи кој е полн квадрат за да премине програмата од јазол А кон јазол С и од јазол С кон јазол E. Од F2 во G ќе се помине за кое било n>0, каде n е големина на низата, а знаеме дека ако n<=0, програмата ќе терминира по јазол B. Сега за да премине од јазол G во H треба низата да има елемент кој е различен од #, а за да премине од јазол G во јазол Q треба да има елемент кој е еднаков на #. Тоа е исполнето во тест примерот затоа се случуваат соодветните премини. За да има премин од H во I треба да има елемент различен од # кој ќе има претходник или следбеник еднаков на #, но во иста редица како него кога ќе ја поставиме листата на следниот начин:

![image](https://user-images.githubusercontent.com/86167204/171653443-f44440a9-0501-44a2-871c-7d1ec1dc02f5.png)


Пример за таков елемент е 0та во 2рата редица што за следбеник има #, не би можеле да кажеме дека има претходник поради тоа што овој елемент се наоѓа на почетокот на матрицата. Од тука за да има премин од I во J треба елементот да има и претходник и следбеник еднаков на # на начинот дискутиран погоре(во една иста редица), односно таков елемент е нулата во првата редица,а за да има премин од  I во K треба елементот да има или претходник или следбеник, но не и двете и таков елемент е 0та во 2рата редица.  За да има премин од H во L треба да има елемент кој нема ни претходник ни следбеник во редицата кој е еднаков на #, а такви се сите нули во последната редица. За да има премин од L во М треба да има елемент различен од # чиј сосед горе, во ваквото матрично прикажување е еднаков на #, таква е 2рата нула во третиот ред во матрицата. А за да има премин од L во N треба да има нула чии горен сосед не постои или е различен од #, a таква е нулата во првиот ред, како и првата нула во последниот ред. За да има премин од N во О треба долниот сосед на некоја нула да е еднаков на #, а таква е нулата во првиот ред. И за да има премин од N во P треба да не постои долниот сосед на некоја нула или тој да е различен од #. Таква, на пример е нулата во првиот ред. Од F2 во R ќе помине од како i ќе добие вредност еднаква на n, односно ќе се измине целата листа.

6. 
При тестирањето се користат следните тестови:


testEveryStatement:
Проверува дали function ќе фрли исклучок од типот IllegalArgumentException со порака која содржи "List length should be greater than 0" за влез празна листа. Дополнително, проверува дали function ќе фрли исклучок од типот IllegalArgumentException со порака која содржи "List length should be a perfect square" за влез ["0", "#"]. Исто така се проверува и дали ["#", "#", "#", "#", "4", "#", "#","#","2"] е излез при влез ["#", "#", "#", "#", "0", "#", "#","#","0"] на функцијата function.


testEveryBranch:
Проверува дали function ќе фрли исклучок од типот IllegalArgumentException со порака која содржи "List length should be greater than 0" за влез празна листа. Дополнително, проверува дали function ќе фрли исклучок од типот IllegalArgumentException со порака која содржи "List length should be a perfect square" за влез ["0", "#"]. Исто така се проверува и дали ["#", "3", "#", "2", "#", "#", "0","1","1"] е излез при влез ["#", "0", "#", "0", "#", "#", "0","0","0"] на функцијата function.

